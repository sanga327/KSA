# 기하학적 변환 실습

> **영상 확대 스케일링 변환**(가장 인접한 이웃 화소 보간법을 이용한 영상 확대, 양선형 보간법)
>
> **영상 축소 스케일링 변환**(미디언 서브 샘플링, 평균 서브 샘플링)
>
> **영상 이동, 대칭, 회전 기하학적 변환**

<br>

- **Class** : ImageProcessingDoc.cpp, ImageProcessingView.cpp
- **Function**
  - **영상 확대**: OnNearest, OnBilinear
  - **영상 축소**: OnMedianSub, OnMeanSub
  - **영상 이동**: OnTranslation
  - **영상 대칭**: OnMirrorHor, OnMirrorVer
  - **영상 회전**: OnRotation

---

- 리소스 뷰

<img src = "https://github.com/sanga327/KSA/blob/main/Module05. 영상처리/Digital_Image_Processing/Document/img/04_img/image-20210522172650017.png">

<br>

---

### 1. 영상의 확대 스케일링 변환

#### 1) 가장 인접한 이웃 화소 보간법을 이용한 영상 확대

- function

```c++
void CImageProcessingDoc::OnNearest()
{
	int i, j;
	int ZoomRate = 2; // 영상 확대 배율
	double **tempArray;

	m_Re_height = int(ZoomRate*m_height); // 확대된 영상의 높이
	m_Re_width = int(ZoomRate*m_width); // 확대된 영상의 너비
	m_Re_size = m_Re_height * m_Re_width;

	m_tempImage = Image2DMem(m_height, m_width);
	tempArray = Image2DMem(m_Re_height, m_Re_width);

	m_OutputImage = new unsigned char[m_Re_size];

	for (i = 0; i < m_height; i++) {
		for (j = 0; j < m_width; j++) {
			m_tempImage[i][j] = (double)m_InputImage[i*m_width + j];
		}
	}

	for (i = 0; i < m_Re_height; i++) {
		for (j = 0; j < m_Re_width; j++) {
			tempArray[i][j] = m_tempImage[i / ZoomRate][j / ZoomRate];
			// 이웃한 화소를 이용한 보간
		}
	}

	for (i = 0; i < m_Re_height; i++) {
		for (j = 0; j < m_Re_width; j++) {
			m_OutputImage[i* m_Re_width + j] = (unsigned char)tempArray[i][j];
		}
	}
}
```



- 실행 결과

<img src = "https://github.com/sanga327/KSA/blob/main/Module05. 영상처리/Digital_Image_Processing/Document/img/04_img/image-20210522173038027.png">

원시 영상을 2배로 확대한 뒤 빈 화소에 보간을 수행하여 부드럽지 못하고 톱니 모양의 뭉툭함이 나타난다.

<br>



#### 2) 양선형 보간법

- function

```c++
void CImageProcessingDoc::OnBilinear()
{
	int i, j, point, i_H, i_W;
	unsigned char newValue;
	double ZoomRate = 2.0, r_H, r_W, s_H, s_W;
	double C1, C2, C3, C4;

	m_Re_height = (int)(m_height * ZoomRate); // 확대된 영상의 높이
	m_Re_width = (int)(m_width * ZoomRate); // 확대된 영상의 너비
	m_Re_size = m_Re_height * m_Re_width;

	m_tempImage = Image2DMem(m_height, m_width);
	m_OutputImage = new unsigned char[m_Re_size];

	for (i = 0; i < m_height; i++) {
		for (j = 0; j < m_width; j++) {
			m_tempImage[i][j] = (double)m_InputImage[i*m_width + j];
		}
	}

	for (i = 0; i < m_Re_height; i++) {
		for (j = 0; j < m_Re_width; j++) {
			r_H = i / ZoomRate;
			r_W = j / ZoomRate;

			i_H = (int)floor(r_H);
			i_W = (int)floor(r_W);

			s_H = r_H - i_H;
			s_W = r_W - i_W;

			if (i_H < 0 || i_H >= (m_height - 1) || i_W < 0
				|| i_W >= (m_width - 1))
			{
				point = i * m_Re_width + j;
				m_OutputImage[point] = 255;
			}

			else
			{
				C1 = (double)m_tempImage[i_H][i_W];
				C2 = (double)m_tempImage[i_H][i_W + 1];
				C3 = (double)m_tempImage[i_H + 1][i_W + 1];
				C4 = (double)m_tempImage[i_H + 1][i_W];

				newValue = (unsigned char)(C1*(1 - s_H)*(1 - s_W)
					+ C2 * s_W*(1 - s_H) + C3 * s_W*s_H + C4 * (1 - s_W)*s_H);
				point = i * m_Re_width + j;
				m_OutputImage[point] = newValue;
			}
		}
	}
}
```



- 실행 결과

<img src = "https://github.com/sanga327/KSA/blob/main/Module05. 영상처리/Digital_Image_Processing/Document/img/04_img/image-20210522173124039.png">

원시 영상을 2배로 확대한 뒤 빈 화소에 양선형 보간법을 적용한 것이다.  <br>

인접한 이웃 화소 보간법 결과보다 부드러워진다.

<br>

---

### 2.영상의 축소 스케일링 변환

#### 1) 미디언 서브 샘플링

- function

```c++
void CImageProcessingDoc::OnMedianSub()
{
	int i, j, n, m, M = 2, index = 0; // M = 서브 샘플링 비율
	double *Mask, Value;

	Mask = new    double[M*M]; // 마스크의 크기 결정

	m_Re_height = (m_height + 1) / M;
	m_Re_width = (m_width + 1) / M;
	m_Re_size = m_Re_height * m_Re_width;

	m_OutputImage = new unsigned char[m_Re_size];
	m_tempImage = Image2DMem(m_height + 1, m_width + 1);

	for (i = 0; i < m_height; i++) {
		for (j = 0; j < m_width; j++) {
			m_tempImage[i][j] = (double)m_InputImage[i*m_width + j];
		}
	}


	for (i = 0; i < m_height - 1; i = i + M) {
		for (j = 0; j < m_width - 1; j = j + M) {
			for (n = 0; n < M; n++) {
				for (m = 0; m < M; m++) {
					Mask[n*M + m] = m_tempImage[i + n][j + m];
					// 입력 영상을 블록으로 잘라 마스크 배열에 저장
				}
			}
			OnBubleSort(Mask, M*M); // 마스크에 저장된 값을 정렬
			Value = Mask[(int)(M*M / 2)]; // 정렬된 값 중 가운데 값을 선택
			m_OutputImage[index] = (unsigned char)Value;
			// 가운데 값을 출력
			index++;
		}
	}
}
```



- 실행 결과

<img src = "https://github.com/sanga327/KSA/blob/main/Module05. 영상처리/Digital_Image_Processing/Document/img/04_img/image-20210522173521688.png">

블러링 전처리로 서브샘플링된 영상과 다르게 원본 영상만큼 화질이 선명하다.

<br>



#### 2) 평균 서브 샘플링

- function

```c++
void CImageProcessingDoc::OnMeanSub()
{
	int i, j, n, m, M = 3, index = 0, k; // M = 서브 샘플링 비율
	double *Mask, Value, Sum = 0.0;

	Mask = new    double[M*M];

	m_Re_height = (m_height + 1) / M;
	m_Re_width = (m_width + 1) / M;
	m_Re_size = m_Re_height * m_Re_width;

	m_OutputImage = new unsigned char[m_Re_size];
	m_tempImage = Image2DMem(m_height + 1, m_width + 1);

	for (i = 0; i < m_height; i++) {
		for (j = 0; j < m_width; j++) {
			m_tempImage[i][j] = (double)m_InputImage[i*m_width + j];
		}
	}

	for (i = 0; i < m_height - 1; i = i + M) {
		for (j = 0; j < m_width - 1; j = j + M) {
			for (n = 0; n < M; n++) {
				for (m = 0; m < M; m++) {
					Mask[n*M + m] = m_tempImage[i + n][j + m];
				}
			}
			for (k = 0; k < M*M; k++)
				Sum = Sum + Mask[k];
			// 마스크에 저장된 값을 누적
			Value = (Sum / (M*M)); // 평균을 계산
			m_OutputImage[index] = (unsigned char)Value;
			// 평균값을 출력
			index++;
			Sum = 0.0;
		}
	}
}
```



- 실행 결과

<img src = "https://github.com/sanga327/KSA/blob/main/Module05. 영상처리/Digital_Image_Processing/Document/img/04_img/image-20210522173610712.png">

영상의 크기가 작아지고 부드러워진다.

<br>

---

### 3. 이동 기하학 변환

- function

```c++
void CImageProcessingDoc::OnTranslation()
{
	int i, j;
	int h_pos = 30, w_pos = 130;
	double **tempArray;

	m_Re_height = m_height;
	m_Re_width = m_width;
	m_Re_size = m_Re_height * m_Re_width;

	m_OutputImage = new unsigned char[m_Re_size];

	m_tempImage = Image2DMem(m_height, m_width);
	tempArray = Image2DMem(m_Re_height, m_Re_width);

	for (i = 0; i < m_height; i++) {
		for (j = 0; j < m_width; j++) {
			m_tempImage[i][j] = (double)m_InputImage[i*m_width + j];
		}
	}

	for (i = 0; i < m_height - h_pos; i++) {
		for (j = 0; j < m_width - w_pos; j++) {
			tempArray[i + h_pos][j + w_pos] = m_tempImage[i][j];
			// 입력 영상을 h_pos, w_pos만큼 이동
		}
	}

	for (i = 0; i < m_Re_height; i++) {
		for (j = 0; j < m_Re_width; j++) {
			m_OutputImage[i* m_Re_width + j]
				= (unsigned char)tempArray[i][j];
		}
	}

	delete[] m_tempImage;
	delete[] tempArray;
}
```

- 실행 결과

<img src = "https://github.com/sanga327/KSA/blob/main/Module05. 영상처리/Digital_Image_Processing/Document/img/04_img/image-20210522180004454.png">

결과 영상이 오른쪽 아래로 이동한다.

<br>

---

### 4. 영상 대칭

#### 1) 영상 좌우 대칭

- function

```c++
void CImageProcessingDoc::OnMirrorHor()
{
	int i, j;

	m_Re_height = m_height;
	m_Re_width = m_width;
	m_Re_size = m_Re_height * m_Re_width;

	m_OutputImage = new unsigned char[m_Re_size];

	for (i = 0; i < m_height; i++) {
		for (j = 0; j < m_width; j++) {
			m_OutputImage[i*m_width + m_width - j - 1] =
				m_InputImage[i*m_width + j];
			// 입력 영상의 배열 값을 출력 영상을 위한 
			// 배열의 수평축 뒷자리부터 저장
		}
	}
}
```



- 실행 결과

<img src = "https://github.com/sanga327/KSA/blob/main/Module05. 영상처리/Digital_Image_Processing/Document/img/04_img/image-20210522180035260.png">

좌우가 바뀌어 출력된다.

<br>

#### 2) 영상 상하 대칭

- function

```c++
void CImageProcessingDoc::OnMirrorVer()
{
	int i, j;

	m_Re_height = m_height;
	m_Re_width = m_width;
	m_Re_size = m_Re_height * m_Re_width;

	m_OutputImage = new unsigned char[m_Re_size];

	for (i = 0; i < m_height; i++) {
		for (j = 0; j < m_width; j++) {
			m_OutputImage[(m_height - i - 1)*m_width + j]
				= m_InputImage[i*m_width + j];
			// 입력 영상의 값을 출력 영상을 위한 배열의 수직축 뒷자리부터 저장
		}
	}
}
```



- 실행 결과

<img src = "https://github.com/sanga327/KSA/blob/main/Module05. 영상처리/Digital_Image_Processing/Document/img/04_img/image-20210522180155057.png">

입력 영상의 위아래가 뒤집힌다.

<br>

---

### 5. 영상 회전

- function

```c++
void CImageProcessingDoc::OnRotation()
{
	int i, j, CenterH, CenterW, newH, newW, degree = 45;
	// degree = 회전할 각도
	double Radian, PI, **tempArray, Value;

	m_Re_height = m_height; // 회전된 영상의 높이
	m_Re_width = m_width; // 회전된 영상의 너비
	m_Re_size = m_Re_height * m_Re_width;

	m_OutputImage = new unsigned char[m_Re_size];
	PI = 3.14159265358979; // 회전각을 위한 PI 값

	Radian = (double)degree*PI / 180.0;
	// degree 값을 radian으로 변경
	CenterH = m_height / 2; // 영상의 중심 좌표
	CenterW = m_width / 2; // 영상의 중심 좌표

	m_tempImage = Image2DMem(m_height, m_width);
	tempArray = Image2DMem(m_Re_height, m_Re_width);

	for (i = 0; i < m_height; i++) {
		for (j = 0; j < m_width; j++) {
			m_tempImage[i][j] = (double)m_InputImage[i*m_width + j];
		}
	}

	for (i = 0; i < m_height; i++) {
		for (j = 0; j < m_width; j++) {
			// 회전 변환 행렬을 이용하여 회전하게 될 좌표 값 계산
			newH = (int)((i - CenterH)*cos(Radian)
				- (j - CenterW)*sin(Radian) + CenterH);
			newW = (int)((i - CenterH)*sin(Radian)
				+ (j - CenterW)*sin(Radian) + CenterW);

			if (newH < 0 || newH >= m_height) {
				// 회전된 좌표가 출력 영상을 위한 배열 값을 넘어갈 때
				Value = 0;
			}
			else if (newW < 0 || newW >= m_width) {
				// 회전된 좌표가 출력 영상을 위한 배열 값을 넘어갈 때
				Value = 0;
			}
			else {
				Value = m_tempImage[newH][newW];
			}
			tempArray[i][j] = Value;
		}
	}

	for (i = 0; i < m_Re_height; i++) {
		for (j = 0; j < m_Re_width; j++) {
			m_OutputImage[i* m_Re_width + j]
				= (unsigned char)tempArray[i][j];
		}
	}
	delete[] m_tempImage;
	delete[] tempArray;
}
```

- 실행 결과

<img src = "https://github.com/sanga327/KSA/blob/main/Module05. 영상처리/Digital_Image_Processing/Document/img/04_img/image-20210522181154152.png">





